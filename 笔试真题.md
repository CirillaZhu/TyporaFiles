### 吃葡萄 吉比特2/3

有一排m串葡萄，每串葡萄有一定个数n的葡萄，一次只能吃某串葡萄的2个加上它左右两边葡萄各1个（1 + 2 + 1），问至少吃完两串葡萄最少需要吃多少次？

输入样例1：

```
3
10 6 5
```

输出样例1：

```
4
```

解释：3串葡萄。吃中间的三次，再吃右边的一次，一共4次就可以吃完两串葡萄。

以下两种样例题目不会给，但是是需要考虑的另外两种情况：

输入样例2：

```
3
1 99 1
```

输出样例2：

```
1
```

解释：3串葡萄。吃中间那一串一次，两边的两串就被吃完了。

输入样例3：

```
4
1 99 99 1
```

输出样例3：

```
2
```

解释：4串葡萄。最左和最右各吃一次，就有两串被吃完了。（或者其它吃法也可以实现2次）



**思路**

- 情况一：吃两串相邻的葡萄
  1. 对于每两串相邻的葡萄，我们可以计算吃完它们所需要的次数。
     - 对于每两串相邻的葡萄：`a[i]`和`a[i+1]`，首先我们可以吃掉`a[i]`的葡萄，吃的次数为`(a[i] + 2) / 4`，`a[i+1]`也会减去对应的葡萄数。同样的，吃`a[i+1]`的次数为`(a[i+1] + 2) / 4`，`a[i]`也会减去对应的葡萄数。取这两种方法中较小的吃的次数。
  2. 从左到右对所有相邻的两串葡萄进行**遍历**，计算出最少需要的次数。

- 情况二：吃两串不相邻的葡萄
- 比较情况一和情况二哪个小



### 比赛排名 吉比特1/3

给定一组长度为n的字符串（'a'-'z'）,代表n只队伍，进行n次比赛，让你求出名次

排名优先判定，排名相同看最高名次的场次，也相同字典序最先

也就是说，a得过第一名，一定比没得过第一名的某队名次高

**案例一**

```cpp
3
abc
abc
abc
```

输出

> abc

a得三次第一，b的三次第二，c的三次第三

**案例二**

```cpp
3
abc
cba
cba
```

输出

> cab

a得一次第一，c得两次第一，所以c第一

b得三次第二，但是由于a得过一次第一，所以a得第二

b得第三



**思路**

理解：每个队伍进行`n`次比赛，每次比赛都会得到一个名次。名次判定的优先级为：最高名次 > 得到该名次的次数 > 字典序。

- 思路一：用数字 rank 记录排名，遍历比赛得第一名 +1000000，第二名 +1000，字典序 +1，最后计算排名即可
- 思路二：记录每个比赛名字，依次排序

```cpp
sort(teams.begin(), teams.end(), [](const pair<string, vector<int>>& a, const pair<string, vector<int>>& b) {
        for(int i = 0; i < a.second.size(); i++) {
            if(a.second[i] > b.second[i]) return true;
            if(a.second[i] < b.second[i]) return false;
        }
        return a.first < b.first;
    });
```



```c++sort(filtered.begin(), filtered.end(), [](vector<int> &v1, vector<int> &v2) -> bool {
sort(filtered.begin(), filtered.end(), [](vector<int> &v1, vector<int> &v2) -> bool {
    return v1[1] > v2[1] || (v1[1] == v2[1] && v1[0] > v2[0]);
});
```





![image-20230820143711302](Typora Pictures/笔试真题.assets/image-20230820143711302.png)



```c++
#include <iostream>
#include<vector>
using namespace std;
vector<vector<vector<bool>>> allAplace;

    //flase 是 B， true 是 A
float calculate(vector<vector<bool>>& place, int m, int n, int c, float d){
    float ans = 0;
    for(int i = 0; i < m; ++i){
        for(int j = 0; j < n; ++j){
            if(!place[i][j]){
                float res = c;
                if(i - 1 > -1 && place[i - 1][j])
                    res *= d;
                if(i - 1 > -1 && j - 1 > -1 && place[i - 1][j - 1])
                    res *= d;
                if(i - 1 > -1 && j + 1 < n  && place[i - 1][j + 1])
                    res *= d;
                if(i + 1 < m && place[i + 1][j])
                    res *= d;
                if(i + 1 < m && j - 1 > -1 && place[i + 1][j - 1])
                    res *= d;
                if(i + 1 < m && j + 1 < n  && place[i + 1][j + 1])
                    res *= d;
                if(j - 1 > -1 && place[i][j - 1])
                    res *= d;
                if(j + 1 < n  && place[i][j + 1])
                    res *= d;
                
                ans += res;
            }
        }
    }
    return ans;
}

void allPlace(int m, int n, int i, int j, int numofA, vector<vector<bool>>& place){
    if(numofA == 0){    // A都放完了，等于完成一种可能
        allAplace.push_back(place);
        return;
    }

    if(i < m){
        if(j < n){
            place[i][j] = true;
            allPlace(m, n, i, j + 1, numofA - 1, place);
            place[i][j] = false;
            allPlace(m, n, i, j + 1, numofA, place);
        }
        else{
            allPlace(m, n, i + 1, 0, numofA, place);
        }
    }
}


int main() {
    int m, n, c;
    float d;
    cin >> m >> n >> c >> d;
    
    vector<vector<bool>> place(m, vector<bool>(n, false));
    allPlace(2, 2, 0, 0, 1, place);

    float ans = 0;
    float sum = 0;
    int possible = 0;
    int ret1, ret2;
    for(int numA = 0; numA < m * n - 1; ++numA){
        sum = 0;
        possible = 0;
        allPlace(m, n, 0, 0, numA, place);
        possible += allAplace.size();
        for(vector<vector<bool>> p : allAplace){
            sum += calculate(p, m, n, c, d);
        }
        //cout << sum << " " << possible << " " << numA << endl;
        if(ans < sum / possible){
            ans = sum / possible;
            ret1 = numA;
            ret2 = n * m - ret1;
        }
        allAplace = {};
    }
    
    cout << ret1<< " "  << ret2<< " ";
    printf("%.1f", ans);

}
// 64 位输出请用 printf("%lld")
```



85% !!nb!





![image-20230820162551408](Typora Pictures/笔试真题.assets/image-20230820162551408.png)



```
6 6 1 2
1 1
2 2 3
5 3 3 3 4 2
3 4 5 6
1 1
1 2
```



```
1 2 4
3 5
```





![image-20230820163608747](Typora Pictures/笔试真题.assets/image-20230820163608747.png)

![image-20230820163622907](Typora Pictures/笔试真题.assets/image-20230820163622907.png)

![image-20230820163632368](Typora Pictures/笔试真题.assets/image-20230820163632368.png)