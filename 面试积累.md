# Unity

#### GC 机制

##### 全称 garbage collection，垃圾回收

- 主要作用在堆空间上



##### 堆上的变量在存储时，分为以下几步：

1）首先，unity检测是否有足够的闲置内存单元，如果有，则分配对应大小的内存单元；

2）如果没有足够的存储单元： 垃圾回收。如果垃圾回收后有足够大小的内存单元，则进行内存分配。

3）如果垃圾回收后没有足够的内存单元：unity 会扩展堆内存的大小（很缓慢），然后分配对应大小的内存单元给变量。



##### 垃圾回收时的操作

当堆内存上一个变量不再处于激活状态的时候，其所占用的内存并不会立刻被回收，不再使用的内存只会在GC的时候才会被回收。



##### 运行GC的时候，主要进行下面的操作：

1）GC会检查堆内存上的每个存储变量；

2）对每个变量会检测其引用是否处于激活状态；

3）如果变量的引用不再处于激活状态，则会被标记为可回收；

4）被标记的变量会被移除，其所占有的内存会被回收到堆内存上。

##### 触发GC

1） 在堆内存上进行内存分配操作而内存不够时

2） GC会自动触发，不同平台运行频率不一样

3） GC可以被强制执行



##### 降低GC的几种方法：

1.**使用对象池** 

对象池，顾名思义就是一定数量的已经创建好的对象(Object)的集合。当需要创建对象时，先在池子中获取，如果池子中没有符合条件的对象，再进行创建新对象，同样，当对象需要销毁时，不做真正的销毁，而是将其setActive(false)，并存入池子中。这样就避免了大量对象的创建。

2.**string和StringBuilder的使用** 

对于执行大量字符串操作的例程 (例如在循环中多次修改字符串的应用程序) ，重复修改字符串可能会显著降低性能。 替代方法是使用 StringBuilder ，它是一个可变字符串类。 可变性是指在创建类的实例后，可以通过追加、移除、替换或插入字符来修改它。 StringBuilder对象维护缓冲区以容纳对字符串的扩展。 如果空间可用，则会将新数据追加到缓冲区;否则，将分配一个新的更大的缓冲区，将原始缓冲区中的数据复制到新缓冲区，然后将新数据追加到新缓冲区。

3.**减少装箱操作** 

装箱指的是值类型转换成引用类型，拆箱则是反过来。

装箱和取消装箱过程需要进行大量的计算。 对值类型进行装箱时，必须创建一个全新的对象。 这可能比一些简单的引用赋值耗时最多能长 20 倍。 取消装箱的过程所需时间也可达赋值操作的四倍，所以尽量避免装箱和拆箱。

4.关键帧限制协程调用（startcoroutine()实际上是new一个对象）

5.用for代替foreach（5.5版本以前有装箱操作，会在堆内存上产生一个system.object）

6.struct中不要有引用类型变量（struct是值类型，而如果struct中有引用类型的变量，GC会检查整个struct）【增加GC的方式是让它检查不必检查的对象】

7.主动调用GC



#### Unity 生命周期

https://www.bilibili.com/video/BV19a41157WP/?spm_id_from=333.337.search-card.all.click&vd_source=120074d428e56ab223e0ce014bbd58b7

https://blog.csdn.net/jiexiaopei_2004/article/details/80027455

**Start（） 注意事项**

在 Start（）中进行初始化不是很安全，因为它可能被其他自定义的函数抢先。

即在脚本A中调用脚本B中的Fun()函数，因为脚本B是被禁用的，所以它在此之前只执行了Awake（）函数而没有执行Start（）函数，当脚本A调用Fun()函数时，会先执行Fun（）函数，再根据脚本是否被禁用而决定是否启用Start（）函数，这会出现如下问题：当Fun（）函数中有些变量需要在Start函数中初始化时，就会出现错误（包括逻辑错误和程序错误）。



#### 对象池



#### 列表集合List及ListArray学习

https://blog.csdn.net/q764424567/article/details/119574671



C++ STL 几个容器的底层实现

https://blog.csdn.net/weixin_43778179/article/details/116662605



linux系统从开机到登陆界面的启动过程

https://blog.csdn.net/qq_15041569/article/details/90576945



unity GC机制

https://blog.csdn.net/qq_43533956/article/details/124237546



c++ 智能指针

https://blog.csdn.net/qq_44139121/article/details/125937906



解决哈希表冲突

https://blog.csdn.net/qq_48241564/article/details/118613312



## c#

https://blog.csdn.net/qq_38199336/article/details/123673608



## 设计模式

##### 单例模式 :heavy_check_mark:

https://www.cnblogs.com/zhili/p/singletonpatterm.html



[C#设计模式总结 - Learning hard - 博客园 (cnblogs.com)](https://www.cnblogs.com/zhili/p/DesignPatternSummery.html)





# 算法

### 快速排序的优化

我们知道快速排序在最坏情况下的时间复杂度是O(n^2)，那有没有办法优化它呢？

我们知道，快速排序的时间复杂度其实和分区点的位置有关的，如果每次分区点都在中间位置，那这个时候的时间复杂度是最低的，如果每次分区点都在两端，则时间复杂度是最坏的。

#### 如何尽量避免最坏的情况出现呢？

避免最坏情况的出现的主要方法就是让分区点两边尽量均匀。那如何让分区点两边尽量均匀呢？常见的有两种方法

1. 随机法
    随机法很简单，就是每次从待排序区间中随机挑选一个作为分区点。可能这个分区点不是最佳的分区点，但是从概率角度讲，它也不大可能是最坏的分区点，平均下来也就可以尽可能的避免最坏的情况出现
2. 取中法
    取中法也很简单，就是取一定的数据进行对比，选出中间值，然后以其作为区分点，比较常见的有三数取中、五数取中等





# c++ 

### 左值引用与右值引用的区别？右值引用的意义？

#### 什么是左值，什么是右值？

左值：在[内存](https://so.csdn.net/so/search?q=内存&spm=1001.2101.3001.7020)有确定存储地址、有变量名，表达式结束依然存在的值，简单来说左值就是非临时对象。

- 可以放到等号左边
- 举例：变量名、返回左值引用的函数调用，前置自增或自减++i、--i、赋值运算或复合赋值运算，解引用

右值：就是在内存没有确定存储地址、没有变量名，[表达式](https://so.csdn.net/so/search?q=表达式&spm=1001.2101.3001.7020)结束就会销毁的值，简单来说右值就是临时对象

- 不可以放到等号左边
- **纯右值**：包含字面值，非引用类型的函数返回值，后置自增与自减，算数表达式、比较表达式、lambda表达式、取地址表达式等(&a)。
- **将亡值**：将亡值是C++11引用的右值引用（移动语义）相关的类型。将亡值用来触发移动构造函数和移动赋值构造函数，进行资源转移，之后将亡值会调用析构函数

左值可以分为两类：非常量左值和常量左值，

    int a=10;              	// a 为非常量左值（有确定存储地址，也有变量名）
    const int a1=10;      //a1 为常量左值（有确定存储地址，也有变量名）
    const int a2=20;      //a2 为常量左值（有确定存储地址，也有变量名）

右值也可以分为两类：非常量右值和常量右值。

```
int a=10;              	// 10 为非常量右值
const int a1=10;      
const int a2=20;      
a1+a2               	// (a1+a2) 为常量右值
```



#### 什么是左值引用和右值引用？有什么区别？

- **左值引用**：对左值进行引用，通过&来获得左值引用。

  - 非常量左值引用只能绑定到非常量左值上；常量左值引用可以绑定所有的值类型

  - ```c++
    int a=10;              //非常量左值（有确定存储地址，也有变量名）
    const int a1=10;       //常量左值（有确定存储地址，也有变量名）
    const int a2=20;       //常量左值（有确定存储地址，也有变量名）
     
    //非常量左值引用
    int &b1=a;            //正确，a是一个非常量左值，可以被非常量左值引用绑定
    int &b2=a1;           //错误,a1是一个常量左值，不可以被非常量左值引用绑定
    int &b3=10;           //错误，10是一个非常量右值，不可以被非常量左值引用绑定
    int &b4=a1+a2;        //错误,（a1+a2）是一个常量右值，不可以被非常量左值引用绑定
    
    //常量左值引用
    const int &c1=a;      //正确，a是一个非常量左值，可以被非常量右值引用绑定
    const int &c2=a1;     //正确,a1是一个常量左值，可以被非常量右值引用绑定
    const int &c3=a+a1;   //正确，（a+a1）是一个非常量右值，可以被常量右值引用绑定
    const int &c4=a1+a2;  //正确,（a1+a2）是一个常量右值，可以被非常量右值引用绑定
    ```

- **右值引用**：对右值进行引用，通过&&来获得右值引用

  - 非常量右值引用只能绑定到非常量右值上；常量右值引用可以绑定到非常量右值、常量右值上。

  - 可以使用std::move函数强制把左值转换为右值。

  - ```c++
    int a=10;             //非常量左值（有确定存储地址，也有变量名）
    const int a1=20;      //常量左值（有确定存储地址，也有变量名）
    const int a2=20;      //常量左值（有确定存储地址，也有变量名）
    
    //非常量右值引用
    int &&b1=a;            //错误，a是一个非常量左值，不可以被非常量右值引用绑定
    int &&b2=a1;           //错误,a1是一个常量左值，不可以被非常量右值引用绑定
    int &&b3=10;           //正确，10是一个常量右值，可以被非常量右值引用绑定
    int &&b4=a1+a2;        //正确,（a1+a2）是一个常量右值，不可以被非常量右值引用绑定
    
    //常量右值引用
    const int &&c1=a;      //错误，a是一个非常量左值，不可以被常量右值引用绑定
    const int &&c2=a1;     //错误,a1是一个常量左值，不可以被常量右值引用绑定
    const int &&c3=a+a1;   //正确，（a+a1）是一个非常量右值，可以被常量右值引用绑定
    const int &&c4=a1+a2;  //正确,（a1+a2）是一个常量右值，不可以被常量右值引用绑定
    
    int &&c = std::move(a); // ok
    ```

- **功能差异**：左值引用的目的是防止函数在进行传参和返回值的时候进行对象拷贝。右值引用是为了移动语义和完美转发，可以延长临时对象的生命周期。

  - 移动语义：转移左右权，对于存储在堆区的数据，如果深拷贝消耗资源比较多。对于那块资源，转为自己所拥有，别人不再拥有也不会再使用

  - 完美转发：可以写一个接受任意实参的函数模板，并转发到其它函数，std::forward()。




## 1. C++从源文件到可执行文件的步骤[#](https://www.cnblogs.com/lihaoxiang/p/17435810.html#1-c从源文件到可执行文件的步骤) 

​	(1) **预处理**：处理所有的预编译指令，生成.i文件。

​	(2) **编译**：经过词法分析、语法分析、语义分析和优化后生成**汇编语言**。生成.s文件

​	(3) **汇编**：将编译阶段生成的汇编文件转化成**机器码**，生成可重定位目标文件。生成.o文件

​	(4) **链接**：将多个目标文件及所需要的库链接成最终的可执行目标文件。生成.out文件

## 2. C++多态[#](https://www.cnblogs.com/lihaoxiang/p/17435810.html#2-c多态) 

### 1）多态的方式有几种[#](https://www.cnblogs.com/lihaoxiang/p/17435810.html#1多态的方式有几种)

**（1）静态多态（重载，模板）**

是在**编译的时候**，就确定调用函数的类型。

**（2）动态多态（覆盖，虚函数实现）**

在**运行的时候**，才确定调用的是哪个函数，动态绑定。运行基类指针指向派生类的对象，并调用派生类的函数。

### 2）多态是什么[#](https://www.cnblogs.com/lihaoxiang/p/17435810.html#2多态是什么)

一个名字多种状态

允许将子类类型的指针赋值给父类类型的指针。多态在C++中都是通过虚函数实现的

虚函数实现原理：虚函数表和虚函数指针。

##### 虚函数与纯虚函数

- 虚函数主要作用是建立抽象模型，方便系统扩展，理解虚函数+继承实现的多态；
- 纯虚函数是被标明为不具体实现的函数，是一种特殊的函数。
- 虚函数必须是类的非静态成员，其访问权限可以是public或者protected；
- 纯虚函数是虚函数的一个子集，用于抽象类，含有纯虚函数的类就是抽象类，他不能生成对象；
- 很多情况下，基类本身生成对象不合理，比如说，动作作为一个基类，可以派生出猴子、老虎等等具体的一种动物，但是动物类本身生成对象明显不合理。
- 为了解决上述问题，引入纯虚函数，将函数定义为纯虚函数，编译器要求在派生类中必须予以重载或者重写而实现多态；同时含有纯虚函数的类他不能生成对象

##### 抽象类

- 抽象类不能实例化；
- 抽象类必须通过继承有派生来实现其方法；即对抽象类不能使用 new 关键字，他也不能被封装；
- 抽象类一定要包含纯虚函数；



### 3）虚函数表和虚指针

虚表是一个指针数组，其中存储了类中所有虚函数的地址。

每个类都有一个虚表，其中存储了该类的所有虚函数的地址。

编译器在编译的时候，发现Base类中有虚函数，此时编译器会为每个包含虚函数的类创建一个虚表（即vtable），该表是一个[一维数组](https://so.csdn.net/so/search?q=一维数组&spm=1001.2101.3001.7020)（而不是一个链表），在这个数组中存放每个虚函数的地址。由于Base类和Derive类都包含了一个虚函数func()，编译器会为这两个类都建立一个虚表。

当一个类被继承时，子类会继承父类的虚表，并在其后面添加自己的虚函数地址。这样，当子类对象调用父类的虚函数时，会通过父类对象的虚指针找到父类的虚表，然后调用相应的函数。而当子类对象调用自己的虚函数时，会通过子类对象的虚指针找到子类的虚表，然后调用相应的函数。

**那么如何定位虚表呢？** 
 编译器另外还为每个带有虚函数的类的对象自动创建一个虚表指针（即vptr），这个指针指向了对象所属类的虚表。在程序运行时，根据对象的类型去初始化vptr，从而让vptr正确的指向所属类的虚表。所以在调用虚函数时，就能够找到正确的函数。



[![img](Typora Pictures/面试积累.assets/v2-e2f479ca9b1c56ac33dfae896ce56f49_720w.webp)](https://pic2.zhimg.com/80/v2-e2f479ca9b1c56ac33dfae896ce56f49_720w.webp)

**那么虚表指针在什么时候，或者说在什么地方初始化呢？** 
 答案是在构造函数中进行虚表的创建和虚表指针的初始化。





## 3. C++访问权限控制符[#](https://www.cnblogs.com/lihaoxiang/p/17435810.html#3-c访问权限控制符) 





# 算法

### A*算法

<img src="Typora Pictures/面试积累.assets/image-20230810140731712.png" alt="image-20230810140731712" style="zoom:50%;" />

- 在广度优先搜索的基础上，进行的进一步优化
- 把搜索过的边界方块标注出来，给每个边界方块计算代价
  - 当前代价：从出发点走到当前方块的路径和（起点的当前代价为 0）
  - 预估代价：当前方块到终点的距离
    - 曼哈顿距离：水平距离 + 竖直距离
    - 欧拉距离：直线距离
- 选择代价最低的方块（用优先队列priority_queue存储）
- 进行周围方块代价的更新











面试官你好，我叫朱昱林，今年25岁，香港中文大学深圳，数据科学专业的研究生。我之前是商科的，做过一些互联网运营，金融行研方面的实习。平时玩的游戏蛮多的，也就越来越想做游戏。我参加过两个gamejam，开发的 demo 糖醋排骨拿了益游未尽的最佳游戏奖。在最近的一次实习中，我参与了一款VR arpg游戏的研发，做了两个小怪自动寻路，动画绑定，攻击伤害逻辑，发射炮弹自动追踪的逻辑，也做了boss的喷火技能；并且手动实现了一个 runtime ai 行为树相关。之前那家公司是做物理引擎的，我也做了十几个物理引擎特性的展示 demo，把unity物理系统的模块基本都用了一遍，并且配上了点击拖拽，UI和移动视角相关的逻辑。

以上是我的个人介绍，看面试官您有什么想详细了解的？





祝您工作顺利~





### 做人设！

贴标签

英语好，精通业务能力，游戏经验丰富，热爱游戏，学习能力强



很多人普通又自信，也拿到大厂offer，要自信！！！我们本来就是会踏实干活的人，本来就太不会包装自己了，

去欧莱雅都是一些很漂亮，被消费主义裹挟，经常freerider，没有data sense的人，不要对自己要求太高！！



c++ 八股！！背！！！重中之重

leetcode，如果有特别难的题，应该是刁难，应该不会给特别难的题目。如果给个hard应该不想招人

无关的实习可以减少一些

最重要的是项目：埋点！按照简历零零散散的问，会没什么印象，层层递进，按照难度去引导面试官提问。把简历相关的东西研究一下。如果能根据一个点问三四十分钟，肯定会与众不同。可以直接说怎么来！

游戏demo优先级往后，针对项目问引擎相关的内容，问源码，背背八股



不是重点：了解 fps 相关的东西，看看fps相关客户端面经



后台高并发，能聊三四十分钟，但其实做的东西只有五到十分钟



网络和操作系统问的不多



一月份面到六月，失败特别多次，可以无限复活



一天看c++八股

一天改项目中的东西，找个亮点，一到两天（重中之重！能引导过去机会会变大很多！！）

一天看面经

机会有很多！要一直准备，要多投简历，八月份把互联网投一遍，一定要多投多面

九月份投银行之类的



##### 请简述你应聘本职位的优势

我有着跨行业的背景，也有着对于技术与游戏的热爱和执着。商科实习的经验让我对人和市场的运行方式更为了解，擅长沟通和合作。而用写代码将游戏制作出来，脚踏实地的一步步完成，不断优化不断求索，去让作品更接近完美，是我真正享受的部分。
我在技术上追求卓越，也在和人相处中倾注感情。我相信好的游戏需要优秀的技术，也需要进取多元的团队，灵感和热爱的碰撞，人和人的互相理解。和人交流合作，互相鼓励中一起制作出卓越的游戏项目，是我最热爱也会全身心投入的事业。



##### 你最喜欢哪些类型游戏或哪几款游戏，并简述原因 （不超过200字）

我最喜欢能引起我心灵震动的游戏，如赛博朋克2077，空洞骑士，gris。它们也许玩法上并不完美，但有着作者倾注的心血。我相信游戏在给人带来快乐的同时，也可以带来更多。

##### 自我评价

- 热爱技术与游戏,拥有良好的沟通协作能力,跨专业的背景带来对业务更好的理解。
- 有较强的信息检索能力，擅长坚决疑难杂症，通过Google/Github/StackOverflow等国外论坛/文档解决技术问题。 





I prefer working in a team. It always cheers me up that get feed back from other teammates.

Passion, diversity and 



INITIAL_RESPONSE = "Welcome to Ecoute 👋"
def create_prompt(transcript):
        return f"""You are a casual pal, genuinely interested in the conversation at hand. A poor transcription of conversation is given below. 
        
{transcript}.

Please respond, in detail, to the conversation. Confidently give a straightforward response to the speaker, even if you don't understand them. Give your response in square brackets. DO NOT ask to repeat, and DO NOT ask for clarification. Just answer the speaker directly. 用中文直接回答"""
